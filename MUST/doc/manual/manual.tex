% Part of the MUST Project, under BSD-3-Clause License
% See https://hpc.rwth-aachen.de/must/LICENSE for license information.
% SPDX-License-Identifier: BSD-3-Clause

% !TeX TS-program = pdflatex

% \documentclass[english]{article}
\documentclass[english]{scrartcl}
\usepackage[latin9]{inputenc}
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{array}
\usepackage{longtable}
\usepackage{varioref}
\usepackage{float}
\usepackage{fancybox}
\usepackage{calc}
\usepackage[usenames]{color}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{setspace}
\usepackage{url}
\usepackage{babel}
\usepackage{listings}
\usepackage{colortbl}
\usepackage{xspace}
\usepackage{hyperref}

% Settings for reproducible pdflatex builds
% See: https://tex.stackexchange.com/a/313605
\pdfinfoomitdate=1
\pdftrailerid{}
\pdfsuppressptexinfo=-1

% P^nMPI
\DeclareMathAlphabet{\mathtr}{OT1}{cmr}{}{n}
\newcommand{\pnmpi}{$\mathop{\mathtr{P^nMPI}}\nolimits$\xspace}


\definecolor{LGREY}{rgb}{0.45,0.45,0.45}

\definecolor{MustBlue1}{rgb}{0.60,0.60,0.87}
\definecolor{MustBlue2}{rgb}{0.47,0.47,0.73}
\definecolor{MustRedDark}{rgb}{1,0.87,0.87}
\definecolor{MustRedLight}{rgb}{1,0.93,0.93}
\definecolor{MustRedDarkGray}{rgb}{0.93,0.80,0.80}
\definecolor{MustRedLightGray}{rgb}{0.93,0.87,0.87}

\emergencystretch = 0 pt
\pretolerance = 150
\tolerance = 10000
\hbadness = 9999
\hfuzz = 0 pt


% redefine paragraph to have a linebreak after it and let \emph work as well
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
  {-3.25ex\@plus -1ex \@minus -.2ex}%
  {1.5ex \@plus .2ex}%
  {\normalfont\normalsize\bfseries}}
\makeatother

\def \MUSTVersion {1.9.0}

\begin{document}

\title{\textsf{\textcolor{blue}{\Huge}}\\
\begin{center}
MUST
\end{center}
\textsf{\large MPI Runtime Error Detection Tool}\\
\vspace{8ex}
\centering\includegraphics[width=0.55\textwidth]{logo.pdf}
\begin{center}
\textsf{\normalfont \normalsize Version \MUSTVersion}\\
\end{center}
}
\maketitle

\newpage{}

\tableofcontents{}

\newpage{}

\section{Introduction}

MUST detects usage errors of the Message Passing Interface (MPI) and reports
them to the user.
As MPI calls are complex and usage errors common, this functionality is
extremely helpful for application developers that want to develop correct MPI applications.
This includes errors that already manifest as segmentation faults or incorrect
results, as well as many errors that are not visible to the application
developer or do not manifest on a particular system or MPI implementation. 

To detect errors, MUST intercepts the MPI calls issued by the target
application and evaluates their arguments. The two main usage
scenarios for MUST arise during application development and during porting.
When a developer adds new MPI communication calls, MUST can detect
newly introduced errors, especially also some that may not manifest in an
application crash. Further,
before porting an application to a new system, MUST can detect violations to the
MPI standard that might manifest on the target system. MUST reports errors
in a log file that can be investigated once the execution of the target
executable finishes (irrespective of whether the application crashed or not).

\section{Installation}

The MUST software consists of three individual packages:
\begin{itemize}
  \item \pnmpi
  \item GTI
  \item MUST
\end{itemize}

The \pnmpi package provides base infrastructure for the MUST software and
intercepts MPI calls of the target application. GTI provides tool
infrastructure, while the MUST package contains the actual correctness checks.

Starting with version 1.6, all three packages are contained in a single archive and configured and built at once.

Each MUST installation is built with a specific compiler and MPI library. It
should only be used for applications built with the same compiler and MPI library. This is necessary as the behavior of MUST may differ
depending on the MPI library. Compilers may be mixed if they are binary
compatible.

Building MUST requires CMake for configuration. It is freely available at
\url{http://www.cmake.org/}. You can execute \emph{which cmake} to determine
whether a CMake installation is available. If not, contact your system
administrator or install a local version, which requires no root
privileges. We suggest to use CMake version 3.9 or later 
(use \emph{cmake \mbox{-{}-}version}) for most functionality.
Individual optional features may require even never CMake versions, which is specified in Section~\ref{section:prerequisites}.
From CMake version 3.20 on, full functionality is supported.

Further, to augment the MUST output with call stack information, which
is very helpful for pinpointing errors, it is possible to utilize Backward or Dyninst. In
that case, MUST uses either Backtrace-cpp or the Stackwalker API from Dyninst to read and print stack traces for errors.
Section~\ref{section:stacktrace} presents the necessary steps for such an
installation.
Additionally, type-matching and data race analyses can be enabled by the integration of TypeART (see Section~\ref{section:typeart}) and ThreadSanitizer (see Section~\ref{section:threaded_apps}), respectively.

MUST supports parallel build. Therefore you may want
to append \emph{\mbox{--}j\textless number of cores\textgreater} to the make
calls.

\subsection{Prerequisites to build and use MUST}
\label{section:prerequisites}
\begin{itemize}
 \item cmake (required 3.9 or newer, optional 3.20 or newer for TypeART, see \emph{cmake \mbox{-{}-version}})
 \item python (required 3, see \emph{python \mbox{-V}})
 \item libxml2 with headers (libxml2-dev / libxml2-devel, required)
 \item graphviz (optional, to generate graphs)
 \item dyninst (optional, see Section~\ref{section:dyninst})
 \item a browser (optional, to view html output)
 \item LLVM lit (optional 12 or newer to run tests, see \emph{tests/README.md})
 \item LLVM FileCheck (optional to run tests, see \emph{tests/README.md})
 \item LLVM-based compiler (optional 10 or newer for TypeART, see Section~\ref{section:typeart})
 \item MPI library, used by the application (required)
\end{itemize}
\subsection{Configuring with CMake}
All parts of MUST use CMake for configuration.
CMake works best with 'out of source' builds, this is what we recommend in
the installation steps below. 
Common CMake options include \verb|-DCMAKE_INSTALL_PREFIX| to set the path to
install into if you do not have root or to provide MUST as module environment package.
CMake options can be configured with a GUI on many systems by using
\verb|ccmake| instead of cmake with all the -D flags listed below.
\begin{itemize}
     \item When the ccmake gui appears:
     \item press c to generate options, press e to move on from any messages displayed by cmake. 
     \item edit any options displayed, 
     \item press c to see if there are any new options resulting from the previous round of choices
     \item repeat until you are happy with the options
     \item press g to generate the build
     \item move on to the make step as usual.
\end{itemize}
\subsection{Building MUST}
MUST can be built as follows (assuming GNU compilers):
\begin{verbatim}
tar xzf MUST-v1.9.0.tar.gz
cd MUST-v1.9.0
mkdir BUILD
cd BUILD
CC=$(which gcc) CXX=$(which g++) FC=$(which gfortran) \
cmake ../ \
     -DCMAKE_INSTALL_PREFIX=<MUST-INSTALLATION-DIR> \
     -DCMAKE_BUILD_TYPE=Release
make -j8 install
export PATH=<MUST-INSTALLATION-DIR>/bin:$PATH
\end{verbatim}

In many cases, it is essential, to use the plain compilers for \emph{CC}\&Co, i.e., not
the MPI compiler wrappers.
The CMake call will determine your MPI installation in order to configure
MUST correctly. If this should fail -- or multiple MPIs are available -- you
can tip the configuration by specifying
\emph{\mbox{--}DMPI\_C\_COMPLIER=$<$FILE\mbox{--}PATH\mbox{--}TO\mbox{--}MPICC$>$} as well as
\emph{\mbox{--}DMPI\_CXX\_COMPLIER=$<$FILE\mbox{--}PATH\mbox{--}TO\mbox{--}MPICXX$>$} and
\emph{\mbox{--}DMPI\_Fortran\_COMPLIER=$<$FILE\mbox{--}PATH\mbox{--}TO\mbox{--}MPIF90$>$} as additional
arguments to the \emph{cmake} command. More advanced users can fine-tune the
detection by specifying additional variables, consult the comments in
\emph{cmakemodules/FindMPI.cmake}. On clusters with special MPI environments, it helps to 
verify that \emph{MPIEXEC} is set to the right mpiexec command (like srun).

Usually, no extra arguments are needed to configure MUST. You can specify
\emph{-DENABLE\_TESTS=On} to activate the test suite that is included in MUST.
Tests should only be started after installing MUST and can be run from within the build directory with:
\begin{verbatim}
make check
\end{verbatim}
or
\begin{verbatim}
make build-test
lit tests
\end{verbatim}
Make sure to invoke the build target \texttt{build-test} before running \texttt{lit} directly to build the tests.
It is invoked implicitly when using the \texttt{check} target.

Some tests will fail even for a correct installation since they document
future extensions. You can get a detailed test report for a single test with:
\begin{verbatim}
make build-test
lit tests/<path/to/test/testname>
\end{verbatim}
To run all \emph{BasicChecks} with up to 4 tests in parallel:
\begin{verbatim}
make build-test
lit -j4 tests/BasicChecks
\end{verbatim}
More information on the test suite can be found in \emph{$<$MUST\mbox{--}SOURCE\mbox{--}DIR$>$/tests/README.md}.

\subsection{Install Prebuilt Configurations}
To speed up the tool preparation time, we provide some prebuilt
configurations for typical tool usage. These can be installed during
building of MUST:
\begin{verbatim}
make -j8 install install-prebuilds
\end{verbatim}
We strongly suggest this step for cluster installations.
If prebuilts are not available, MUST will prepare an appropriate
configuration during the execution of mustrun.

\subsection{Environmentals}
\label{section:environmentals}
To work with MUST, it is sufficient to add \emph{$<$MUST\mbox{--}INSTALLATION\mbox{--}DIR$>$/bin} 
to your \emph{PATH} variable. 

\section{Usage}

The following two steps allow you to use MUST:
\begin{itemize}
\item Replace the \emph{mpiexec} command with
\emph{mustrun} to execute your application;
\item Inspect the result file of the run.
\end{itemize}

\subsection{Execution}

The actual execution of an application with MUST is done by replacing the
\emph{mpiexec} command with \emph{mustrun}. It performs a code generation step
to adapt the MUST tool to your application and will run your application with MUST afterward. 

The plain \emph{mustrun} command that we use here is intended for small scale
short-running applications and can exhibit very high runtime overhead.
Section~\ref{section:must-modes} presents further configurations of MUST that
we tested with up to $16,384$ processes.  The plain \emph{mustrun} command uses
all of MUST's correctness checks and a communication system where one MPI 
process is used to drive some of these
checks. So when submitting a batch job,
you should make sure to allocate resources for one additional task. Further,
when calling \emph{mustrun} you need to have access to the compilers and MPI
utilities that were used to build MUST itself.

A regular \emph{mpiexec} command like:
\begin{verbatim}
mpiexec -np 4 application.exe
\end{verbatim}
Is replaced with:
\begin{verbatim}
mustrun -np 4 application.exe
\end{verbatim}
It will execute your application with four tasks but requires one additional task,
i.e. it will actually invoke \emph{mpiexec} with \emph{\mbox{-np 5}}.

For an example where the \emph{mpiexec} command and the switch used to
specify the number of processes is named differently:
\begin{verbatim}
srun -n 4 application.exe
\end{verbatim}
You could use the following\emph{mustrun} command:
\begin{verbatim}
mustrun --must:mpiexec srun --must:np -n  -n 4 application.exe
\end{verbatim}

\noindent{}If your machine provides no compilers in batch jobs, you can prepare
a run as follows:
\begin{verbatim}
mustrun --must:mode prepare -np 4 application.exe
\end{verbatim}
In your batch job you would then just execute:
\begin{verbatim}
mustrun --must:mode run -np 4 application.exe
\end{verbatim}

\noindent{}The \emph{mustrun} tool provides further switches to modify its
behavior, call \mbox{\emph{mustrun \mbox{-{}-must:help}}} for a summary.  
If you
encounter errors during execution, please submit error reports where you use \emph{\mbox{-{}-must:verbose}} as
an argument to \emph{mustrun}.

It is not possible to pass arguments to mustrun that contain whitespace characters like spaces or tabs using command line switches.
Use environment variables to pass such arguments to \emph{mustrun} (see Section~\ref{section:envvar_args}).


\subsubsection{Passing arguments by environment variables}
\label{section:envvar_args}
You can also use environment variables to pass switches to \emph{mustrun}.

Every command line switch has a corresponding environment variable.
These variables are named like the switches according to these rules:
\begin{itemize}
	\item the two leading hyphens are removed
	\item all characters are converted to upper case
	\item colons and hyphens are replaced by underscores
\end{itemize}
For example the switch \texttt{--must:output-dir} can also be set with the environment variable \texttt{MUST\_OUTPUT\_DIR}.

Command line switches take precedence over environment variables.
If both are used for the same switch, then the argument passed by the environment variable gets overridden by the command line argument.

Note the placement of quotes in the following example with whitespace in an MUST argument:
\begin{verbatim}
env "MUST_MPIEXEC=mpiexec --verbose" mustrun -np 4 application.exe
\end{verbatim}


\subsection{Execution of threaded applications}
\label{section:threaded_apps}
For support of threaded applications, MUST provides a thread-safe mode:
\begin{verbatim}
mustrun --must:hybrid -np 4 application.exe
\end{verbatim}
Be aware that MUST lifts the required MPI threading level in this case to
\texttt{MPI\_THREAD\_MULTIPLE}, while MUST limits the provided threading level without
this flag to \texttt{MPI\_THREAD\_SINGLE}.

\subsubsection{OpenMP Applications}
MUST supports analyzing hybrid applications using MPI and OpenMP, e.g., checking thread level usage.
For that, MUST makes use of the OMPT interface, which was introduced in OpenMP 5.0.
Thus, in order to use the OpenMP mode, a recent compiler with OMPT support is required (e.g., LLVM/Intel/Cray compiler).
The OpenMP mode implicitly enables the hybrid thread-safe mode, it suffices to run the application with
\begin{verbatim}
mustrun --must:openmp -np 4 application.exe
\end{verbatim}
while making sure that the application is built with OpenMP support (\texttt{-fopenmp}) and executes with multiple threads (\texttt{OMP\_NUM\_THREADS} > 1).
\subsubsection{Data Race Detection}
MUST additionally features checks to detect data races involving MPI communication in hybrid programs with the help of ThreadSanitizer\footnote{\url{https://clang.llvm.org/docs/ThreadSanitizer.html}}, which can be enabled by
\begin{verbatim}
mustrun --must:tsan -np 4 application.exe
\end{verbatim}
This requires MUST to be configured with \verb|-DENABLE_TSAN=On| (enabled by default) and the application under test to be compiled with \verb|-fsanitize=thread| (supported by GNU- and LLVM-based compilers).
Currently, ThreadSanitizer integration for data race detection is fully supported with the clang compiler from version 6 up to 13 and gcc version 9 to 11.
The application also has to be linked with \emph{$<$MUST\mbox{--}INSTALLATION\mbox{--}DIR$>$/lib/libonReportLoader.a} and built with debug info for MUST to generate meaningful reports for detected data races.
Some linkers may not add unused symbols of the library to the application, in which case it helps to tell the linker to include all symbols from the library
\begin{verbatim}
$CC app.c -g \
    -Wl,--whole-archive install/must/lib/libonReportLoader.a \
    -Wl,--no-whole-archive \
    --fsanitize=thread
\end{verbatim}

Support for newer compiler versions is experimental.
The application must not be linked with \emph{libonReportLoader.a} and data races will not be reported in MUST's HTML report but only on standard output.

If MUST is configured with \verb|-DENABLE_STACKTRACE=On| (enabled by default, see Section~\ref{section:stacktrace}), information from the stacktraces will be used for reports on data races.
To check whether MUST is configured properly with ThreadSanitizer support, run
\begin{verbatim}
make build-test
lit tests/MpiTSan
\end{verbatim}
or
\begin{verbatim}
make check-MpiTSan
\end{verbatim}
For the tests however MUST has to be built with either gcc or clang in one of the aforementioned versions.

\subsection{Results}
MUST stores its results in an HTML file named \emph{MUST\_Output.html}. It
contains information on all detected issues, including information on where the
error occurred.
By default the \emph{MUST\_Output.html} file is placed in the execution directory.
The output directory can be specified via \mbox{\emph{\mbox{-{}-must:output-dir $<$path$>$}}}.

Moreover, MUST's output can be split across multiple files by the user.
To this end, the application under test may call \texttt{GTI\_ChangeMessageFile(filename)}, which will result in MUST writing output to \texttt{filename}.
This requires including the \texttt{GTI\_Annotations.h} header and adding \emph{$<$MUST\mbox{--}INSTALLATION\mbox{--}DIR$>$/include} to the include path for compilation.
Note that the filename can be altered multiple times during execution.
The filename is interpreted relative to MUST's main output directory.

\subsubsection{Filtering Messages}
MUST also allows its output to be filtered according to user-defined rules.
Filter rules have the following general format: \texttt{messageType:MUST\_ERROR\_TYPE:source}, where \texttt{MUST\_ERROR\_TYPE} determines which type of errors or warnings to filter out (e.g., \texttt{MUST\_ERROR\_TYPEMATCH\_MISMATCH}) and \texttt{source} is one of the following:

\begin{itemize}
    \item specific file as \texttt{source}: \texttt{src:\textit{filename.c}}
    \item specific function as \texttt{source}: \texttt{func:\textit{function\_name}}
    \item every \texttt{source}: \texttt{*}
\end{itemize}

For example, the rule \texttt{messageType:MUST\_WARNING\_COMM\_NULL:src:main.c} would filter out all of MUST warning regarding \texttt{MPI\_COMM\_NULL} or \texttt{NULL} as a communicator handle resulting from the source file \texttt{main.c}.
The first two type of rules require MUST to use stacktraces, which can be enabled with the \mbox{\emph{\mbox{-{}-must:stacktrace}}} option (see Section~\ref{section:stacktrace}).

Multiple filter rules may be specified in a file line by line and given to MUST via \mbox{\emph{\mbox{-{}-must:filter-file $<$file$>$}}}.
Alternatively, the environment variable \texttt{MUST\_FILTER\_FILE} can be set to the file.
The error type printed with each message in the report can be used to suppress such error output.
For a list of more supported \texttt{MUST\_ERROR\_TYPES} see \emph{$<$MUST\mbox{--}SOURCE\mbox{--}DIR$>$/modules/Common/MustEnums.h}.

\subsubsection{Output Modes}
Instead of printing out HTML, MUST may also log its output to stdout or generate a JSON-file.
The output mode can be specified with \mbox{\emph{\mbox{-{}-must:output $<html|stdout|json>$}}}.
The json-mode aims to ease automatic parsing of MUST's output.

An example output for MUST's json-mode:

\begin{lstlisting}[tabsize=3,numbers=none,basicstyle=\scriptsize,%
	breaklines=true, frame=single,%
    commentstyle=\color{LGREY}, keywordstyle=\bfseries,%
    numbers=left, numbersep=5pt,numberstyle=\tiny,%
	name=example-interface-listing, firstnumber=1]
{
'messages': 
[
    {
      'type': 'Error',
      'error_id': 'MUST_ERROR_LEAK_DATATYPE',
      'text': 'There are 1 datatypes that are not freed [...] at reference 1',
      'from': {
        'call': 'MPI_Type_contiguous',
        'ranks': [ 0 ],
        'ranks_strided': false
    },
    'references': [{
      'no': 1,
      'call': 'MPI_Type_contiguous',
      'rank': 0,
      'threadid': 0,
      'stacktrace': [

        ]
      }]
    }
]
}
\end{lstlisting}
\subsubsection{Instant Logging}
By default, MUST reports the same error occuring on different ranks only once for the sake of clarity.
Depending on the MPI library, however, this mode may prevent MUST from reporting errors that cause the application to crash.
MUST can be forced to immediately report errors, \mbox{\emph{\mbox{-{}-must:instant-logging $<$info|warning|error|fatal$>$}}} can be used.
Note that through this option, the same error occuring on different ranks will only be reported for one of the ranks.

\section{Example}
As an example consider the following application that contains three MPI usage
errors:

\begin{lstlisting}[tabsize=3,numbers=none,basicstyle=\scriptsize,%
	breaklines=true,language=C, frame=single,%
	commentstyle=\color{LGREY},
    keywordstyle=\bfseries,%
	identifierstyle=\texttt,
    numbers=left, numbersep=5pt,numberstyle=\tiny,%
	name=example-interface-listing, firstnumber=1, showspaces=false, showstringspaces=false]
#include <stdio.h>
#include <mpi.h>

int main (int argc, char** argv)
{
    int rank,
        size,
        sBuf[2] = {1,2},
        rBuf[2];
    MPI_Status status;
    MPI_Datatype newType;

    MPI_Init(&argc,&argv);
    MPI_Comm_rank (MPI_COMM_WORLD, &rank);
    MPI_Comm_size (MPI_COMM_WORLD, &size);

    //Enough tasks ?
	if (size < 2)
	{
		printf ("This test needs at least 2 processes!\n");
		MPI_Finalize();
		return 1;
	}

	//Say hello
	printf ("Hello, I am rank %d of %d processes.\n", rank, size);

	//1) Create a datatype
	MPI_Type_contiguous (2, MPI_INT, &newType);
	MPI_Type_commit (&newType);

	//2) Use MPI_Sendrecv to perform a ring communication
	MPI_Sendrecv (
	        sBuf, 1, newType, (rank+1)%size, 123,
	        rBuf, sizeof(int)*2, MPI_BYTE, (rank-1+size) % size, 123,
	        MPI_COMM_WORLD, &status);

	//3) Use MPI_Send and MPI_Recv to perform a ring communication
	MPI_Send (sBuf, 1, newType, (rank+1)%size, 456, MPI_COMM_WORLD);
	MPI_Recv (rBuf, sizeof(int)*2, MPI_BYTE, (rank-1+size) % size, 456, MPI_COMM_WORLD, &status);

	//Say bye bye
	printf ("Signing off, rank %d.\n", rank);

    MPI_Finalize ();

    return 0;
}
/*EOF*/
\end{lstlisting}

\subsection{Execution with MUST}

A user could set up the environment for MUST, build the application, and run
it with the following commands:

\begin{verbatim}
#Set up environment
export PATH=<MUST-INSTALLATION-DIR>/bin:$PATH

#Compile and link, we rely on the ld-preload mechanism
mpicc example.c -o example.exe -g

#Run with four processes. We will need resources for five tasks!
mustrun -np 4 example.exe
\end{verbatim}

\subsection{Output File}

The output of the run with MUST will be stored in a file named
\emph{MUST\_Output.html}. For this application MUST will detect three different
errors that are:
\begin{itemize}
  \item A type mismatch (Figure~\ref{result-type})
  \item A send-send deadlock (Figure~\ref{result-deadlock} )
  \item A leaked datatype (Figure~\ref{result-leak} )   
\end{itemize}

\begin{figure}[t]
  \centering
  \includegraphics[angle=0,width=0.99\linewidth]{outputtypemismatch.pdf}
  \caption{Type mismatch error report from MUST.}
  \label{result-type}
  \includegraphics[angle=0,width=0.99\linewidth]{typemismatch.pdf}
  \caption{Detail page for the type mismatch in
  Figure~\ref{section:must-modes}.}
  \label{result-type-dot}
\end{figure}
% \begin{table}[hbtp]
% \begin{longtable}[t]{|m{0.05\textwidth}|m{0.06\textwidth}|m{0.38\textwidth}|m{0.14\textwidth}|m{0.23\textwidth}|}
% 
%     \multicolumn{5}{p{\textwidth}}{\textbf{MUST Output}, date: Thu Aug 25 09:04:01 2011.}\\\hline
%     \footnotesize\cellcolor{MustBlue1}\begin{center}\textbf{Rank} \end{center}&
%     \footnotesize\cellcolor{MustBlue2}\begin{center}\textbf{Type} \end{center}&
%     \footnotesize\cellcolor{MustBlue1}\begin{center}\textbf{Message} \end{center}&
%     \footnotesize\cellcolor{MustBlue2}\begin{center}\textbf{Form} \end{center}&
%     \footnotesize\cellcolor{MustBlue1}\begin{center}\textbf{References} \end{center}\\\hline
% 
% 
%     \footnotesize\cellcolor{MustRedDark}\begin{center}0\end{center} &
%     \footnotesize\cellcolor{MustRedLight}\begin{center}\textbf{Error}\end{center} &
%     \footnotesize\cellcolor{MustRedDark}\begin{center} A send and a receive
%     operation use datatypes that do not match! Mis-match occurs at (CONTIGUOUS)[0](MPI\_INT) in the send type and at (MPI\_BYTE) in the receive type (consult the MUST manual for a detailed description of datatype positions). The send operation was started at reference 1, the receive operation was started at reference 2. (Information on communicator: MPI\_COMM\_WORLD) (Informationon send of count 1 with type: Datatype created at reference 3 is for C, commited at reference 4, based on the following type(s): MPI\_INT) (Information on receive of count 8 with type:MPI\_BYTE)\end{center}& \footnotesize\cellcolor{MustRedLight}\begin{center}call MPI\_Sendrecv\end{center}&
%    \footnotesize\cellcolor{MustRedDark}\begin{center} reference 1: call\newline MPI\_Sendrecv @rank 3\newline
% reference 2: call\newline MPI\_Sendrecv @rank 0\newline
% reference 3: call\newline MPI\_Type\_contiguous @rank 3\newline
% reference 4: call\newline MPI\_Type\_commit @rank 3\end{center}\\
% \hline
% \end{longtable}
% \caption{Type mis-match error report from MUST.}
% \label{result-type}
% \centering
% \end{table}

Figure~\ref{result-type} shows the first error that MUST detects. The error
results from the usage of non-matching datatypes, which are an \texttt{MPI\_INT}
and an \texttt{MPI\_BYTE} of the same size as the integer value. This is not
allowed according to the MPI standard. A correct application would use
\texttt{MPI\_INT} for both the send and receive call.

If MUST is configured with Dyninst (Section~\ref{section:dyninst}), the right column will list call stacks for all the involved MPI calls, as in
Figure~\ref{section:must-modes}. 
Here the 
error is detected in the \texttt{MPI\_Sendrecv} call in line 33.

The example shows the specification of the location in the datatype that causes
the mismatch. 
The location \texttt{(CONTIGUOUS)[0](MPI\_INT)} means that the used
datatype is of contiguous kind. The mismatch is within the first element of the
contiguous type, which is defined to be a base type, namely \texttt{MPI\_INT}.

As another example \texttt{(VECTOR)[1][2](MPI\_CHAR)} would address the third
entry of the second block of a vector with base-type \texttt{MPI\_CHAR}.

Figure~\ref{result-type-dot} displays a graphical representation of the type
mismatch. The image shows type trees of the involved data types. For a correct type match,
both trees should share all their leaves. For a clearer view, matching leaves
are hidden. The path to the first clash is highlighted in red.
For derived types, the node labels display the count/blocklength value, 
used in the 
declaration of the type, while the edge label (corresponding to the path expression) 
gives the index of the block/blockitem, that leads to the first clash. 

For communication buffers that access the same memory address concurrently
("buffer overlap"), similar descriptions and graphs are used. In this case, all nodes that point to distinct memory addresses are hidden, as the focus lies on the
representation of the memory overlap.

\begin{figure}[tp]
  \centering
  \includegraphics[angle=0,width=0.99\linewidth]{outputdeadlock.pdf}
  \caption{Send-send deadlock report from MUST, basic report.}
  \label{result-deadlock}
  \includegraphics[angle=0,width=0.99\linewidth]{deadlock.pdf}
  \caption{Deadlock view for the send-send deadlock.}
  \label{result-deadlock-dot}
\end{figure}

% \begin{table}[hbtp]
% \begin{longtable}[t]{|m{0.05\textwidth}|m{0.06\textwidth}|m{0.38\textwidth}|m{0.14\textwidth}|m{0.23\textwidth}|}
% 
%     \multicolumn{5}{p{\textwidth}}{\textbf{MUST Output}, date: Thu Aug 25 09:04:01 2011.}\\\hline
%         \footnotesize\cellcolor{MustBlue1}\begin{center}\textbf{Rank} \end{center}&
%         \footnotesize\cellcolor{MustBlue2}\begin{center}\textbf{Type} \end{center}&
%         \footnotesize\cellcolor{MustBlue1}\begin{center}\textbf{Message} \end{center}&
%         \footnotesize\cellcolor{MustBlue2}\begin{center}\textbf{Form} \end{center}&
%         \footnotesize\cellcolor{MustBlue1}\begin{center}\textbf{References} \end{center}\\\hline
% 
%         \footnotesize\cellcolor{MustRedDark}&
%         \footnotesize\cellcolor{MustRedLight}\begin{center}\textbf{Error}\end{center}&
%         \footnotesize\cellcolor{MustRedDark}\begin{center}The application issued a set of MPI calls that can cause a deadlock! A graphical representation of this situation is available in the file named "MUST\_Deadlock.dot". Use the dot tool of the graphviz package to visualize it, e.g. issue "dot -Tps MUST\_Deadlock.dot -o deadlock.ps". The graph shows the nodes that form the root cause of the deadlock, any other active MPI calls have been removed. A legend is available in the dot format in the file named "MUST\_DeadlockLegend.dot", further information on these graphs is available in the MUST manual. References 1-4 list the involved calls (limited to the first 5 calls, further calls may be involved). The application still runs, if the deadlock manifested (e.g. caused a hang on this MPI implementation) you can attach to the involved ranks with a debugger.\end{center}&
%         \footnotesize\cellcolor{MustRedLight}&
%         \footnotesize\cellcolor{MustRedDark}\begin{center}reference 1: call\newline MPI\_Send@rank 0\newline
% reference 2: call\newline MPI\_Send@rank 1\newline
% reference 3: call\newline MPI\_Send@rank 2\newline
% reference 4: call\newline MPI\_Send@rank 3 \end{center}\\
% \hline
% \end{longtable}
% \caption{Send-send deadlock report from MUST.}
% \label{result-deadlock}
% \centering
% \end{table}

The second error results from the application calling send calls that can lead
to deadlock (Figure~\ref{result-deadlock}). Each task issues one call to
\texttt{MPI\_Send} while no matching receive is available. This can cause
deadlock. However, as such calls would be buffered for most MPI implementations, this is a deadlock that only manifests
for some message sizes or MPI implementations. 
 
% \begin{figure}[hbtp]
% 	\centering
%     \subfigure[Wait-for
%     graph.]{\centering\includegraphics[width=0.25\textwidth]{deadlock.png}}
%     \subfigure[Legend]{\includegraphics[width=0.45\textwidth]{deadlockLegend.png}}
%     \caption{Visualization of the send-send deadlock from
%     Table~\ref{result-deadlock}.}
%     \label{figure-deadlock}
% \end{figure}

If MUST detects a deadlock, it provides visualization for its core, i.e., the
set of MPI calls of which at least one call has to be modified or replaced.
It stores a wait-for graph representation of this core in a file named
\emph{MUST\_Deadlock.dot}. 
If available, MUST automatically translates this file into an image and provides
a deadlock view (Figure~\ref{result-deadlock-dot}), which shows the task
dependencies and a parallel call stack.
This graph file uses the DOT language of the
\emph{Graphviz} package. 
If a graphviz installation was available when
MUST was installed, it automatically visualizes the
graph. Otherwise, you can visualize it by issuing \emph{dot -Tps
MUST\_Deadlock.dot -o deadlock.ps} after installing this tool.
You can open the file \emph{deadlock.ps} with the postscript viewer of your choice (DOT also supports additional output formats).
If MUST was
configured with Dyninst (Section~\ref{section:dyninst}), it will also print a
parallel call stack in a file called \emph{MUST\_DeadlockCallStack.dot}, which
Figure~\ref{result-deadlock-dot} shows at the bottom. This stack includes any
MPI call that was referred to in the wait-for graph. Especially if processes use
non-blocking communications, this call stack may include multiple MPI calls for
each process.

Further graphs in the deadlock view show information about the message
matching state to highlight any call that might have been intended to match a
blocked point-to-point call. Since no outstanding point-to-point message exists
in the deadlock situation of Figure~\ref{result-deadlock}, these graphs are
empty.

\begin{figure}[t]
  \centering
  \includegraphics[angle=0,width=0.99\linewidth]{resleak.pdf}
  \caption{Resource leak report from MUST.}
  \label{result-leak}
\end{figure}
%\begin{table}[hbtp]
%\begin{longtable}[t]{|m{0.05\textwidth}|m{0.06\textwidth}|m{0.38\textwidth}|m{0.14\textwidth}|m{0.23\textwidth}|}
%
%     \multicolumn{5}{p{\textwidth}}{\textbf{MUST Output}, date: Thu Aug 25 09:04:01 2011.}\\\hline
%         \footnotesize\cellcolor{MustBlue1}\begin{center}\textbf{Rank} \end{center}&
%         \footnotesize\cellcolor{MustBlue2}\begin{center}\textbf{Type} \end{center}&
%         \footnotesize\cellcolor{MustBlue1}\begin{center}\textbf{Message} \end{center}&
%         \footnotesize\cellcolor{MustBlue2}\begin{center}\textbf{Form} \end{center}&
%         \footnotesize\cellcolor{MustBlue1}\begin{center}\textbf{References} \end{center}\\\hline
% 
%         \footnotesize\cellcolor{MustRedDark}&
%         \footnotesize\cellcolor{MustRedLight}\begin{center}\textbf{Error}\end{center} &
%         \footnotesize\cellcolor{MustRedDark}\begin{center}There are 1 datatypes that are not freed when MPI\_Finalize was issued, a quality application should free all MPI resources before calling MPI\_Finalize. Listing  information for these datatypes:\newline\newline
% -Datatype 1: Datatype created at reference 1 is for C, commited at reference 2, based on the following type(s): MPI\_INT  \end{center}&
%         \footnotesize\cellcolor{MustRedLight}&
%         \footnotesize\cellcolor{MustRedDark}\begin{center}reference 1: call\newline MPI\_Type\_contiguous @rank 0\newline
% reference 2: call\newline MPI\_Type\_commit @rank 0\end{center}\\
% \hline
% \end{longtable}
% \caption{Resource leak report from MUST.}
% \label{result-leak}
% \centering
% \end{table}

Finally, MUST detects that the application leaks MPI resources when calling
\texttt{MPI\_Finalize}. In particular,
this is a datatype created with an \texttt{MPI\_contiguous} call. Applications
should free all such resources before invoking \texttt{MPI\_Finalize}, as
harmful leaks are easier to detect
in such cases.

\section{MUST's Operation Modes}
\label{section:must-modes}

MUST's analysis of all MPI calls causes runtime overhead. As a result, it is
important to adapt its configuration such that its overhead stays acceptable.
While its default configuration (\emph{mustrun} without additional switches) is
easy to use, more advanced configurations may be required. MUST's overhead
primarily results from:
\begin{itemize}
  \item Correctness checks that require information from multiple processes, and
  \item A communication mode that allows MUST to detect MPI usage errors even if
  the application crashes. 
\end{itemize}

MUST can use more than one additional process to run expensive correctness
checks, while a shared memory based communication mode allows MUST to tolerate
application crashes with limited runtime overhead.

\subsection{Mode Overview}

MUST provides the following operation modes that adapt its overhead to the
target use-case:
\begin{enumerate}
  \item \textbf{(Default) Very slow, Centralized, application may crash:}
  \begin{itemize}
    \item Command line: \emph{mustrun \mbox{-np X} exe}
    \item One extra process for correctness checking
    \item All checks enabled
    \item Detects errors even if application crashes
    \item Very slow, for short running tests at $<32$ processes
  \end{itemize}
  \item \textbf{Fast, centralized, application does not crash:}
  \begin{itemize}
    \item Command line: \emph{mustrun \mbox{-np X} \mbox{-{}-must:nocrash} exe}
    \item One extra process for correctness checking
    \item All checks enabled
    \item Detects errors only if the application does not crash %(but is
    %allowed to hang)
    \item Limited scalability, use for $<100$ processes 
  \end{itemize}
  \item \textbf{Fast, centralized, application may crash:}
  \begin{itemize}
    \item Command line: \emph{mustrun \mbox{-np X} \mbox{-{}-must:nodesize Y} exe}
    \item Number of extra processes: $1+\lceil{}\frac{X}{Y-1}\rceil{}$
    \item All checks enabled
    \item Detects errors even if application crashs
    \item Limited scalability, use for $<100$ processes
    \item Requires shared memory communication (Available on most linux based
    clusters) 
  \end{itemize}
  \item \textbf{Distributed, application does not crash:}
  \begin{itemize}
    \item Command line: \emph{mustrun \mbox{-np X} \mbox{-{}-must:distributed} [\mbox{-{}-must:fanin Z}] exe}
    \item Network of extra processes:
    \begin{itemize}
      \item Layer $0$: $A=\lceil{}\frac{X}{Z}\rceil{}$
      \item Layer $1$: $B=\lceil{}\frac{A}{Z}\rceil{}$
      \item \ldots
      \item Layer $k$: 1
    \end{itemize}
    \item If you need to reduce overheads, you can disable MUST's distributed deadlock detection with \emph{\mbox{-{}-must:nodl}}
    \item Detects errors only if the application does not crash %(but is
    %allowed to hang)
    \item Tested with $16,384$ processes 
  \end{itemize}
  \item \textbf{Distributed, application may crash:}
  \begin{itemize}
    \item Command line: \\\emph{mustrun \mbox{-np X} \mbox{-{}-must:distributed} \mbox{-{}-must:nodesize Y} [\mbox{-{}-must:fanin Z}] exe}
    \item Network of extra processes:
    \begin{itemize}
      \item Layer $0$: $A=\lceil{}\frac{X}{Y-1}\rceil{}$
      \item Layer $1$: $B=\lceil{}\frac{A}{Z}\rceil{}$
      \item Layer $2$: $C=\lceil{}\frac{B}{Z}\rceil{}$
      \item \ldots
      \item Layer $k$: 1
    \end{itemize}
    \item If you need to reduce overheads, you can disable MUST's distributed deadlock detection with \emph{\mbox{-{}-must:nodl}}
    \item Tested with $4,096$ processes 
    \item Requires shared memory communication (Available on most linux based clusters)
  \end{itemize}
\end{enumerate} 

\subsection{Mode Details}

For any non-demanding (short and small scale) use case, we suggest operation Mode~1 (\emph{mustrun \mbox{-np X} exe}), since it is always available and easy to use.

For more extensive application runs at moderate scale ($<100$ processes) users
should either use Mode~2 (\emph{mustrun \mbox{-np X} \mbox{-{}-must:nocrash} exe}) or Mode~3
(\emph{mustrun \mbox{-np X} \mbox{-{}-must:nodesize Y} exe}). While Mode~2 assumes that the
application does not crash, Mode~3 uses a shared memory communication (Linux
message queues) to tolerate application crashes. Besides the limited availability
of this communication mechanism (most Linux-based systems), it requires more
than one extra process to operate. The user needs to specify a node size $Y$ that
is a divisor of the number of cores available within each compute node. MUST
then uses one tool process per $Y-1$ application processes. It is important that
the resource manager distributes MPI ranks in node-core order. That is, it fills
each node completely and with successive ranks. The use of the
\emph{\mbox{-{}-must:fillnodes}} switch to the \emph{mustrun} command may help if the
total number of MPI ranks does not fill all allocated nodes causing the
resource manager to not fill nodes completely.

By adding the \emph{\mbox{-{}-must:info}} switch to any \emph{mustrun} command, the user
may retrieve additional information on the number of application tasks, tool
tasks, and required nodes without running or preparing a MUST run. This provides
valuable information to prepare batch job allocations.

Modes~4 (\emph{mustrun \mbox{-np X} \mbox{-{}-must:distributed} [\mbox{-{}-must:fanin Z}] exe}) and 5
(\emph{mustrun \mbox{-np X} \mbox{-{}-must:distributed} \mbox{-{}-must:nodesize Y} [\mbox{-{}-must:fanin Z}] exe})
are intended for application runs at scale ($>100$ processes, where we
tested MUST with up to $16{,}384$ processes). Both modes use a tree network to
run several correctness checks, which increase their demand for extra computing
cores. Again Mode~4 assumes that the application does not crash, while Mode~5
uses a shared memory communication to tolerate application crashs. Mode~5 comes
with the same restrictions and allocation assumptions as Mode~3. For
both modes, the user may specify the \emph{\mbox{-{}-must:fanin Z}} switch which
controls the ratio of application to extra tool processes. The default
value is $16$, higher values may increase MUST's overhead, while lower
values may reduce its overhead. Experience with MUST's
distributed deadlock detection shows that it
scales to an order of $16{,}384$ processes but can double
MUST's overhead. 
If MUST's overhead is too high for your use-case, you can add the switch
\emph{\mbox{-{}-must:nodl}} to disable the distributed deadlock detection for Modes~4 and~5. 

\section{Included Checks}
MUST currently provides correctness checks for the following classes of errors:
\begin{itemize}
  \item Constants and integer values
  \item Communicator usage
  \item Datatype usage
  \item Group usage
  \item Operation usage
  \item Request usage
  \item Leak checks (MPI resources not freed before
  calling \texttt{MPI\_Finalize})
  \item Type mis-matches
  \item Overlapping buffers passed to MPI
  \item Deadlocks resulting from MPI calls
  \item Data races involving MPI calls
\end{itemize}

\subsection{Identifying use of unsupported MPI functions}
MUST informs about the usage of MPI functions in the application for which no analysis is offered yet.
For an example report of unsupported MPI functions, see Figure~\ref{unsupported-report}.

\begin{figure}[tp]
  \centering
  \includegraphics[angle=0,width=0.99\linewidth]{unsupported_example.pdf}
    \caption{MUST report on unsupported MPI functions \texttt{MPI\_Mprobe} and \texttt{MPI\_Mrecv}.}
  \label{unsupported-report}
\end{figure}

\subsection{MPI 4.0 Support}
Starting with version 1.9, MUST includes basic MPI 4.0 support.
Currently, MPI 4.0 support is limited to correctness checks for Partitioned Point-to-Point Communication and the tracking of resources (e.g. communicators) created through MPI 4.0 functions.
However, explicitly not yet covered with analyses are
\begin{itemize}
    \item MPI Sessions
    \item New function variants \texttt{MPI\_\textit{XXX}\_c} using \texttt{MPI\_Count}
    \item Persistent collectives
\end{itemize}
In particular this also means, MUST requires the usage of the \textit{World Model} (\texttt{MPI\_Init[\_thread]} and \texttt{MPI\_COMM\_WORLD}) by the application.

\section{Stack trace information in MUST reports}
\label{section:stacktrace}
MUST relies on external libraries to generate source code information included in MUST reports. The \emph{\mbox{-{}-must:stacktrace}} switch allows selecting the stack trace mechanism when launching mustrun. Since collecting stack traces can be costly and introduce significant runtime overhead, MUST will not collect stack traces by default. Therefore, the default of this setting is \emph{none}.
To enable stack traces based on backward-cpp, use \emph{\mbox{-{}-must:stacktrace backward}}. 
To enable stack traces based on Dyninst, use \emph{\mbox{-{}-must:stacktrace dyninst}}. 
The individual options will only be available if MUST was built with support for the individual stack trace library as described in the following.
A single installation of MUST can be built with support for both stack trace libraries at the same time.

\subsection{Recommended: MUST Installation with Backward-cpp}
\label{section:backward}
Since MUST version 1.8, MUST is configured with backward-cpp support enabled by default. To install MUST \textit{without} backward-cpp support, the CMake variable \textbf{\mbox{-DUSE\_BACKWARD=Off}} must be explicitly set during the configuration of MUST. Backward-cpp can work with different libraries to unwind the call stack\footnote{\url{https://github.com/bombela/backward-cpp/\#libraries-to-unwind-the-stack}} and to read the debug information from the binary\footnote{\url{https://github.com/bombela/backward-cpp/\#libraries-to-read-the-debug-info}}. The backward-cpp CMake configuration will automatically detect and select available debugging libraries.

\subsection{Optional: MUST Installation with Dyninst}
\label{section:dyninst}
In order to install MUST with Dyninst support, a full Dyninst installation or a
separate installation of the Dyninst Stackwalker API is needed. This usually
requires an installation of libdwarf. Installation instructions for these can be
found on the Dyninst website\footnote{\url{https://www.dyninst.org/}}. We tested the integration of dyninst in versions 7.0.1 and 8.0.1 and stackwalkerAPI in versions 2.1 and 8.0.1.
For some systems, we identified issues for the older version of dyninst, 
that are listed in Section \ref{subsect:dyninst-issues}. 
We suggest to
install libdwarf as a shared library (\emph{\mbox{-{}-}enable-shared} during its
configure).

As Dyninst's build support is currently limited to GNU compilers, you should 
build your application and the tool with binary compatible compilers. 
To build dyninst 
with compilers other than GNU, make sure to set the variables \emph{CC}, \emph{CXX}, 
\emph{GXX}, \emph{LD} and \emph{LINKER} for both the configure and the make step 
(this is not supported).

After a successful installation of the Stackwalker API it is necessary
to configure MUST to use this installation. Use the following CMake variables:
\begin{itemize}
  \item \textbf{-DUSE\_CALLPATH=On} Enables the feature
  \item \textbf{-DSTACKWALKER\_INSTALL\_PREFIX=} Should point to the 
  directory used for Stackwalker API installation (i.e. prefix given to its
  configure)
  \item \textbf{-DCALLPATH\_STACKWALKER\_EXTRA\_LIBRARIES=} Additional libaries
  that are needed, if libdwarf was built statically, you will need to add an
  absolute file path to this lib here
\end{itemize}

Afterwards run \emph{make} and \emph{make install} to build and install MUST.
When running MUST, no additional steps are needed. However, the stackwalker
library will only be able to extract source file names and line numbers if the
application was built with the debugging flag \emph{-g}. Otherwise, it will list
symbol addresses and library names instead.

Note that MUST expects that the shared libraries for libdwarf (if built as a shared library) 
and libelf are in the \texttt{LD\_LIBRARY\_PATH}.

\section{TypeART Integration}
\label{section:typeart}
MUST's native type mis-match detection focuses on distributed mis-matches, e.g., a send and a matching receive call using two incompatible data types. 
In order to additionally check for local type mis-matches, MUST provides optional integration of the type and memory allocation tracker TypeART\footnote{\url{https://github.com/tudasc/TypeART}}.

\subsection{MUST Preparation}
By default, an existing and installed version of TypeART will be used for MUST.
However, if TypeART is not installed at this system, the TypeART sources will be included as submodule and built from source.
TypeART support requires an LLVM-based compiler in version 10 or newer and can be enabled during the configuration with \textbf{\mbox{-DENABLE\_TYPEART=On}}.
MUST will automatically detect and enable TypeART support if applicable during the configuration.

\subsection{Application Preparation}
As TypeART relies on code instrumentation, its compiler wrapper needs to be used for compilation.
For detailed information on requirements on and preparation of the application to test see \emph{$<$MUST\mbox{--}SOURCE\mbox{--}DIR$>$/externals/typeart/README.md}.
In case TypeART was built from source as a submodule, the needed wrappers can be found under \emph{$<$MUST\mbox{--}INSTALLATION\mbox{--}DIR$>$/bin}, i.e,
if you followed the suggetion in Section~\ref{section:environmentals} the wrappers will be available without any other manual tweaking.

\subsection{Execution}
If MUST was configured with TypeART support and the application was built accordingly, MUST's TypeART checks can be enabled via the option \emph{\mbox{-{}-must:typeart}}.
To check whether MUST is configured properly for TypeART checks, run
\begin{verbatim}
make build-test
lit tests/TypeArt
\end{verbatim}
or
\begin{verbatim}
make check-TypeArt
\end{verbatim}

\section{Troubleshooting}

The following lists currently known problems or issues and potential
workarounds.

\subsection{Issues with Ld-Preload}
In order to use MUST, your application must be linked against the core library of
\pnmpi. Per default, MUST will add this library at execution time by using the
ld-preload mechanism. If this causes issues, you can use the following
command to manually link the \pnmpi library:
\begin{verbatim}
mpicc source.c -L<PNMPI-INSTALLATION-DIR>/lib  \
        -lpnmpi -o application.exe
\end{verbatim}

Important: if you manually link against the MPI library, you must add the \pnmpi
library first and the MPI library afterwards.

\subsection{Issues with stackwalkerAPI}
\label{subsect:dyninst-issues}

\paragraph{boost related error while build of MUST with dyninst-8:}
\begin{verbatim}
error: boost/bar_foo.hpp: File not found
\end{verbatim}
Solution for boost installation outside of /usr:

Edit \emph{mustsrc/modules/Callpath/CMakeLists.txt} insert around line 21:
\begin{verbatim}
include_directories(/<BOOST_INSTALL_PREFIX>/include)
\end{verbatim}

\paragraph{SEGFAULT on execution of \emph{mustrun}:}
\begin{verbatim}
  rank 0 (of 4), pid 12345 catched signal nr 11
\end{verbatim}
without any of the WARNINGs listed below. This issue affects almost every installation.\newline\newline
Solution:

Edit \emph{src/dyninst/symtabAPI/src/Object-elf.C} around line 2069 and replace:
\begin{verbatim}
  if(secNumber >= 1 && secNumber <= regions_.size()) {
\end{verbatim}
by
\begin{verbatim}
  if(secNumber >= 0 && secNumber < regions_.size()) {
\end{verbatim}
... and rebuild / install dyninst

\paragraph{SEGFAULT on execution of \emph{mustrun}:}
\begin{verbatim}
  rank 0 (of 4), pid 12345 catched signal nr 11
\end{verbatim}
without any of the WARNINGs listed below and after fixing the issue above.\newline\newline
Solution:

Make sure that you use the same compiler family for building dyninst, \pnmpi, 
GTI, MUST and your application!

\paragraph{\emph{mustrun} reports missing library:}

\begin{verbatim}
  WARNING: Can't load module libcallpathModule.so (Error libdwarf.so: 
  cannot open shared object file: No such file or directory)
\end{verbatim}
Solution:

Add \emph{\textless LIBDWARF\mbox{--}INSTALLATION\mbox{--}DIR\textgreater/lib} to 
\emph{LD\_LIBRARY\_PATH} (\emph{libdwarf.so} should be located there).


\section{Copyright and Contact}
MUST is distributed under a BSD style license. For details, see the file
\mbox{LICENSE.txt} in its package. MUST uses parts of external code, mostly distributed under BSD style license. In any case the license is indicated in the source file, and in the external directories, a LICENSE file can be found.
Finally, \pnmpi is distributed under LGPL license. The license file is located in 
\mbox{externals/GTI/externals/PnMPI/LICENSE}.


Contact \emph{must-feedback@lists.rwth-aachen.de} for bug reports, feedback, and
feature requests.

\end{document}
