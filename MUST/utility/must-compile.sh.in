#!/usr/bin/env bash
set -e

POSITIONAL_ARGS=()

function ifdryrun() {
  if [[ $dryrun -eq 1 || $verbose -eq 1 ]]; then
    echo $1
  fi
  if [[ $dryrun -eq 0 ]]; then
    eval $1
  fi
}

function print_help() {
    name=$(basename $0)
    printf "$name is a compiler wrapper to statically instrument memory accesses"
    printf "\nvia TSan (plus optional optimizations) and link a TSan runtime to the binary"
    printf "\nfor RMA race detection."
    printf "\nRequires Clang >= @RMAOPT_CLANG_VERSION_MIN@."
    printf "\n\nUsage: $0 [--tsan-rt <arg>] [--rmaopt-plugin <arg>] [--optimizations <arg>] [--onreport-path <arg>] [--dry-run] [--verbose] [--wrap-target <arg>] <compiler-params>"
    printf "\n\t --tsan-rt: Path to static or dynamic TSan runtime to be linked. Defaults to shipped with RMAOptimizerPlugin"
    printf "\n\t --rmaopt-plugin: Path to LLVM plugin to use"
    printf "\n\t --optimizations: Optimizations to use, comma separated. See RMAOptimizerPlugin documentation for details"
    printf "\n\t --onreport-path: Specify static onreport library to use. If unset, use bundled from MUST. If set to 'none', disables onreport link"
    printf "\n\t --print-opt-stats: Print statistics of opt call (requires LLVM build with LLVM_FORCE_ENABLE_STATS=1)"
    printf "\n\t --dry-run: Only show the commands that would be run, but do not perform any"
    printf "\n\t --wrap-target: Set the compiler to wrap around"
    printf "\n\t --verbose: Print commands to be executed"
    printf "\n\t --help: Print this help text and exit"
    printf "\n"
}

function parse_cmd() {
unset rem_args
unset optimizations
unset compiler_bin
dryrun=0
verbose=0

MUST_COMPILER_ONREPORT_PATH="${MUST_COMPILER_ONREPORT_PATH:-@MUST_ONREPORT_PATH@}"
MUST_COMPILER_TSAN_RUNTIME="${MUST_COMPILER_TSAN_RUNTIME:-@RMAOPT_INSTALLED_TSAN_LIB@}"
MUST_COMPILER_OPT_PLUGIN="${MUST_COMPILER_OPT_PLUGIN:-@RMAOPT_INSTALLED_PLUGIN_PATH@}"

compiler_onreport_string=""
compiler_tsan_rtl_string=""
opt_params=""

while [[ $# -gt 0 ]]; do
  case $1 in
    --help)
      print_help
      exit 0
      ;;
    --dry-run)
      dryrun=1
      shift # past value
      ;;
    --verbose)
      verbose=1
      shift # past value
      ;;
    --tsan-rt)
      MUST_COMPILER_TSAN_RUNTIME="$2"
      shift # past argument
      shift # past value
      ;;
    --rmaopt-plugin)
      MUST_COMPILER_OPT_PLUGIN="$2"
      shift # past argument
      shift # past value
      ;;
    --onreport-path)
      MUST_COMPILER_ONREPORT_PATH="$2"
      shift # past argument
      shift # past value
      ;;
    --wrap-target)
      compiler_bin="$2"
      shift # past argument
      shift # past value
      ;;
    --optimizations)
      optimizations="$2"
      shift # past argument
      shift # past value
      ;;
    --print-opt-stats)
      opt_params="-stats"
      shift # past value
      ;;
    *)
      rem_args+=( "$1" )
      shift # past argument
      ;;
  esac
done
}

parse_cmd $@

##
## Set default compiler target if needed
##
if [[ "${compiler_bin}" == "" ]]; then
  compiler_bin="@COMPILER_WRAP_EXPR@"
fi

##
## Sanity Checks
##

# Check that some form of Clang is used
compiler_name=$(${compiler_bin} --version | head -n 1)
if ! [[ "${compiler_name}" =~ .*(c|f)lang ]]; then
    printf "Compiler is unsupported! Detected: ${compiler_name}\n"
    exit 1
fi

# Check that Clang version is OK
clang_ver_detect_regex=".*(c|f)lang(\+\+)? version ([0-9]*)\..*"
clang_major=$(${compiler_bin} --version | head -n 1 | sed -rE "s/${clang_ver_detect_regex}/\3/g")
if [[ ${clang_major} -lt @RMAOPT_CLANG_VERSION_MIN@ ]]; then
    printf "Clang version is unsupported! Minimum Required: @RMAOPT_CLANG_VERSION_MIN@. Detected: ${clang_major}\n"
    exit 1
fi

# Onreport should include whole-archive flag only when not set"
if [[ "$MUST_COMPILER_ONREPORT_PATH" != "none" ]]; then
  compiler_onreport_string="-Wl,--whole-archive '${MUST_COMPILER_ONREPORT_PATH}' -Wl,--no-whole-archive"
fi

# Fix up TSan runtime flag
if [[ "$MUST_COMPILER_TSAN_RUNTIME" =~ .*".a" ]]; then
  compiler_tsan_rtl_string="-Wl,--whole-archive '${MUST_COMPILER_TSAN_RUNTIME}' -Wl,--no-whole-archive"
  if [[ -f ${MUST_COMPILER_TSAN_RUNTIME}.syms ]]; then
    compiler_tsan_rtl_string+=" -Wl,--dynamic-list='${MUST_COMPILER_TSAN_RUNTIME}.syms'"
  fi
else
  compiler_tsan_rtl_string="-Wl,--whole-archive '${MUST_COMPILER_TSAN_RUNTIME}' -Wl,--no-whole-archive"
fi

# Check print-stats environment variable
if [[ "$MUST_COMPILER_PRINT_STATS" == "1" ]]; then
  opt_params="-stats"
fi


##
## Run actual compiler stuff
##

# Get source files, and generate corresponding IR
unset SRC_FILE_PATHS
unset SRC_FILE_NAMES
unset TMP_OBJ_FILES
unset filtered_rem_args
skip_linker=0
dest_path_spec=""
opt_level_string=""
append_str=""
for (( i=0; i < ${#rem_args[@]}; i++ )); do
  cur="${rem_args[@]:$i:1}" # Weird syntax needed for bash/zsh cross compatibility
  if [[ "$cur" =~ (@MUST_COMPILE_SRC_FILE_ENDINGS@)$ ]]; then
    CUR_FILE="$cur"
    SRC_FILE_PATHS+=( "$CUR_FILE" )
    CUR_FILE="$(echo "$CUR_FILE" | sed -E 's/(@MUST_COMPILE_SRC_FILE_ENDINGS@)$//')"
    SRC_FILE_NAMES+=( "$(basename "$CUR_FILE")" )
  elif [[ "$cur" == "-o" ]]; then
    dest_path_spec="$cur ${rem_args[@]:i+1:1}"
    ((i++)) || true
  elif [[ "$cur" == "-MT" ]]; then
    append_str="$append_str $cur ${rem_args[@]:i+1:1}"
    ((i++)) || true
  elif [[ "$cur" == "-c" ]]; then
    skip_linker=1
  elif [[ "$cur" == "-E" ]]; then
    skip_linker=2
  else
    filtered_rem_args+=( "$cur" )
    if [[ "$cur" =~ -O[0123] ]]; then
      opt_level_string="$cur"
    fi
  fi
done

# Remove object files from args. They will be treated in the linker step, if executed
rem_args="${filtered_rem_args[@]}"

# Get IR for source files, if any exist
if [[ ${#SRC_FILE_PATHS[@]} -gt 0 ]]; then
  filenames="$(echo ${SRC_FILE_PATHS[@]})" # Workaround for weird expansion issue
  # Remove output flag
  tmp_rem_args="$(echo "$rem_args" | sed -E 's/(^| )-o \S+//')"
  # Do not allow non-source files yet, only in linker step.
  tmp_rem_args="$(echo "$tmp_rem_args" | sed -E 's/\S+(\.so|\.o|\.a)([\s]|$)//')"
  # Add back output flag, if no linker used
  if [[ $skip_linker -ge 1 ]]; then
    tmp_rem_args="$tmp_rem_args $dest_path_spec"
  fi
  # Use -c if mixed linker call or linker skip, use -E if only preprocessor (skip_linker=2)
  if [[ $skip_linker -lt 2 ]]; then
    tmp_rem_args="-c $tmp_rem_args"
  else
    tmp_rem_args="-E $tmp_rem_args"
  fi

  # Generate IR for source files
  ifdryrun "${compiler_bin} -S -emit-llvm -Xclang -disable-O0-optnone $tmp_rem_args $append_str $filenames"


  if [[ $dest_path_spec == "" ]] && [[ $skip_linker -eq 1 ]]; then
    # No output dir specified, but objects requested. Above command generated .ll instead of .o files
    for file_base in "${SRC_FILE_NAMES[@]}"; do
      # Move such that they end on .o instead
      ifdryrun "mv ${file_base}.ll ${file_base}.o"
    done
  elif [[ $skip_linker -eq 0 ]]; then
    # Linker is NOT being skipped, so generated object files are temporary. So move them to a temporary location
    for file_base in "${SRC_FILE_NAMES[@]}"; do
      tmpfile=$(mktemp --suffix=.ll)
      ifdryrun "mv ${file_base}.ll ${tmpfile}"
      TMP_OBJ_FILES+=( "${tmpfile}" )
    done
  fi
fi

# Exit early if linker unwanted
if [[ $skip_linker -ge 1 ]]; then
  exit 0
fi

##
## Link Steps
##

# Object files are those in args that end on .o, or those generated from source in earlier compile step
OBJ_FILES=( "$(echo $rem_args | tr ' ' '\n' | grep "\.o" || true)" "${TMP_OBJ_FILES[@]}" )

for OBJ_FILE in ${OBJ_FILES[@]}
do
    # remove OBJ_FILES from args
    rem_args=${rem_args//$OBJ_FILE/}
done

# Add back output flag.
# Must be after the above to make sure that if output includes .o it is not counted as required object file
rem_args="$rem_args $dest_path_spec"

tmpfile=$(mktemp --suffix=.ll)

optimizations_arg="$(echo "${optimizations}" | sed 's/,/ /g')"
opt_passlist_string="$(@RMAOPT_OPT_CONFIGURE_SCRIPT@ --get-config passes ${optimizations_arg})"
opt_argument_string="$(@RMAOPT_OPT_CONFIGURE_SCRIPT@ --get-config args ${optimizations_arg})"

# link together object files
ifdryrun "llvm-link -S ${OBJ_FILES[*]} -o ${tmpfile}"
ifdryrun "opt ${opt_params} -load-pass-plugin ${MUST_COMPILER_OPT_PLUGIN} -passes='"${opt_passlist_string}"' ${opt_argument_string} ${tmpfile} -o ${tmpfile}.opt"
ifdryrun "llc ${opt_level_string} ${tmpfile}.opt -o ${tmpfile}.opt.o -filetype=obj --relocation-model=pic"
ifdryrun "${compiler_bin} $rem_args ${compiler_onreport_string} ${compiler_tsan_rtl_string} -lm ${tmpfile}.opt.o"
